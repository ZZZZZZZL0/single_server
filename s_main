clear;

function SH6(num)					// input: an integer

V2:=VectorSpace(GF(2),32);
			//8个hash初值
h0 := 0x6a09e667;	     h0:=V2!(Reverse(Intseq(h0,2,32)));	//保证高位在左
h1 := 0xbb67ae85;       h1:=V2!(Reverse(Intseq(h1,2,32)));
h2 := 0x3c6ef372;        h2:=V2!(Reverse(Intseq(h2,2,32)));
h3 := 0xa54ff53a;         h3:=V2!(Reverse(Intseq(h3,2,32)));
h4 := 0x510e527f;        h4:=V2!(Reverse(Intseq(h4,2,32)));
h5 := 0x9b05688c;       h5:=V2!(Reverse(Intseq(h5,2,32)));
h6 := 0x1f83d9ab;       h6:=V2!(Reverse(Intseq(h6,2,32)));
h7 := 0x5be0cd19;       h7:=V2!(Reverse(Intseq(h7,2,32)));
			//64个hash常量
kt:=[
   0x428a2f98,    0x71374491,   0xb5c0fbcf,    0xe9b5dba5,   0x3956c25b,   0x59f111f1,     0x923f82a4,    0xab1c5ed5,
   0xd807aa98,   0x12835b01,   0x243185be,  0x550c7dc3,    0x72be5d74,   0x80deb1fe,    0x9bdc06a7,   0xc19bf174,
   0xe49b69c1,   0xefbe4786,    0x0fc19dc6,    0x240ca1cc,    0x2de92c6f,    0x4a7484aa,    0x5cb0a9dc,    0x76f988da,
   0x983e5152,   0xa831c66d,   0xb00327c8,   0xbf597fc7,     0xc6e00bf3,    0xd5a79147,   0x06ca6351,    0x14292967,
   0x27b70a85,   0x2e1b2138,   0x4d2c6dfc,    0x53380d13,   0x650a7354,   0x766a0abb,   0x81c2c92e,    0x92722c85,
   0xa2bfe8a1,    0xa81a664b,   0xc24b8b70,   0xc76c51a3,    0xd192e819,   0xd6990624,   0xf40e3585,    0x106aa070,
   0x19a4c116,   0x1e376c08,    0x2748774c,   0x34b0bcb5,   0x391c0cb3,   0x4ed8aa4a,    0x5b9cca4f,     0x682e6ff3,
   0x748f82ee,    0x78a5636f,    0x84c87814,   0x8cc70208,    0x90befffa,     0xa4506ceb,    0xbef9a3f7,      0xc67178f2 ];
//_________________________________________________________________
v2i:=function(x)			             //域向量转整数
        //   v:=Eltseq(x);
v:=[0: i in [1..Degree(x)]];
for i in [1..#v] do
	if x[i] eq 1 then
		v[i]:=1;
	end if;
end for;
           return Seqint(Reverse(v),2);   //magma中高低位与二进制相反
end function;
//_________________________________________________________________
i2v:=function(n)			             //整数转域向量
           return V2!( Reverse(Intseq(n mod 2^32,2,32)) );
end function;
//_________________________________________________________________
sigma0:=function(x)
           v1:=Rotate(x,7);     v2:=Rotate(x,18);       //循环右移
           v3:=Rotate(x,3);   	for i in [1..3] do   //右移
			      v3[i]:=0;
			end for;
           return v1+v2+v3;
end function;
//_________________________________________________________________
sigma1:=function(x)
           v1:=Rotate(x,17);     v2:=Rotate(x,19);       //循环右移
           v3:=Rotate(x,10);   	for i in [1..10] do   //右移
			      v3[i]:=0;
			end for;
           return v1+v2+v3;
end function;
//_________________________________________________________________
Sigma0:=function(x)
           v1:=Rotate(x,2);     v2:=Rotate(x,13);     v3:=Rotate(x,22);
           return v1+v2+v3;
end function;
//_________________________________________________________________
Sigma1:=function(x)
           v1:=Rotate(x,6);     v2:=Rotate(x,11);     v3:=Rotate(x,25);
           return v1+v2+v3;
end function;
//_________________________________________________________________
Ch:=function(x,y,z)   			       //choice
v1:=x;	v2:=x;
for i in [1..Degree(x)] do
	if x[i] eq 1 and y[i] eq 1 then 	//按位与
		v1[i]:=1;
	else
		v1[i]:=0;
	end if;

	if x[i] eq 0 and z[i] eq 1 then
		v2[i]:=1;
	else
		v2[i]:=0;
	end if;
end for;
	return v1+v2;
end function;
//_________________________________________________________________
Ma:=function(x,y,z)   			    //majority
v1:=x;	v2:=x;	v3:=x;
for i in [1..Degree(x)] do
	if x[i] eq 1 and y[i] eq 1 then	//按位与
		v1[i]:=1;
	else
		v1[i]:=0;
	end if;

	if x[i] eq 1 and z[i] eq 1 then	//按位与
		v2[i]:=1;
	else
		v2[i]:=0;
	end if;

	if y[i] eq 1 and z[i] eq 1 then	//按位与
		v3[i]:=1;
	else
		v3[i]:=0;
	end if;
end for;
	return v1+v2+v3;
end function;
//__________________________________________________________________________________
					       //INPUT
ipnm:=Reverse(Intseq(num,2));
lenim:=#ipnm;   		   
			// 附加填充比特  至448位
//__________________________________________________________________________________
ipnm[#ipnm+1]:=1;   
padd:=512-64-(lenim mod 512)-1;
ipnm:=ipnm cat [0: i in[1..padd]];
			//附加长度值
temp:=Reverse(Intseq(lenim,2,64));  
ipnm:=ipnm cat temp;      
//__________________________________________________________________________________
			//构造64个word，每一个32bit
wt:=[];
for i := 1 to 16 by 1 do 
	wt[i]:=V2!(ipnm[32*(i-1)+1..32*i]);
end for;
//__________________________________________________________________________________
for i := 17 to 64 by 1 do 
            tempwt:=v2i(sigma1(wt[i-2]))+v2i(wt[i-7])+v2i(sigma0(wt[i-15]))+v2i(wt[i-16]);
            wt[i]:=i2v(tempwt);
end for;    		//已得到64个word: #wt=64
//__________________________________________________________________________________
					          //循环
a:=h0;   b:=h1;   c:=h2;   d:=h3;   
e:=h4;   f:=h5;    g:=h6;   h:=h7; 
for i in [1..64] do
        tp1:=v2i(h)+v2i(Sigma1(e))+v2i(Ch(e,f,g))+v2i( V2!(Reverse(Intseq(kt[i],2,32))) )+v2i(wt[i]);
        tp2:=v2i(Sigma0(a))+v2i(Ma(a,b,c));	        //big integers
        h:=g;    g:=f;   f:=e;    
	tpe:=v2i(d)+tp1;     e:=i2v(tpe);   
        d:=c;    c:=b;   b:=a;   
	tpa:=tp1+tp2;   	a:=i2v(tpa);  
end for;

hout:=[];
hout[1]:=(v2i(h0)+v2i(a)) mod 2^32;   hout[2]:=(v2i(h1)+v2i(b)) mod 2^32;   
hout[3]:=(v2i(h2)+v2i(c)) mod 2^32;   hout[4]:=(v2i(h3)+v2i(d)) mod 2^32;
hout[5]:=(v2i(h4)+v2i(e)) mod 2^32;   hout[6]:=(v2i(h5)+v2i(f))  mod 2^32;
hout[7]:=(v2i(h6)+v2i(g)) mod 2^32;   hout[8]:=(v2i(h7)+v2i(h)) mod 2^32;
//_________________________________________________________________________________
					    //OUTPUT
Enc_num:=[];
for i in [1..#hout] do
    Enc_num:= Enc_num cat Reverse(Intseq(hout[i],2,32));
end for;

return Seqint(Reverse(Enc_num),2);
end function;
//__________________*********************************************_________________








// ____________________________FUNCTION Pohlig-Hellman____________________________
function PH(alphain,betain,p)
gq:=GF(p);         alpha:= gq!alphain;      
crt1:=[];          crt2:=[];           a:=[];           Q:=[];          C:=[];
n:=p-1;            fpi:=Factorization(n);                
for u in [1..#fpi] do
    Q[u]:=fpi[u,1];      C[u]:=fpi[u,2];      crt2[u]:=Q[u]^C[u];
    a[u]:=[];      q:=Q[u];      c:=C[u];
    beta:=gq!betain;        j:=1;
    
while j le c do          
    delta:=beta^( n div q^j ) ; 
    i:=1;              // temp:=alpha^( i*n* q^(-1) ) ;
    temp:=alpha^( i*n div q );
    while i le q^c and delta ne temp do
        i:=i+1;        temp:=alpha^( i*n div q );
    end while;
    a[u][j]:=i;
    beta:=beta*alpha^( -a[u][j]*q^(j-1) );
    j:=j+1;
end while;       // get all the elements in a[u] in terms of  q=Q[u], c=C[u]

crt1[u]:=0;
for id in [ 1..c ] do
    crt1[u]:=crt1[u]+a[u][id]*q^(id-1) ;
end for;

end for;

return ChineseRemainderTheorem(crt1,crt2);
end function;
//_____________________________________________________________________________








gentry:=function(query_index,n,e,S,P,ed)
// ____________________________________ input _________________________________     
if ed eq 1 then
    io:=Ceiling(Log(2,n));     t:=Ceiling(n/io);      k:=Ceiling(Log(2,n)); // it is the last line,0-1DB
else
    io:=Ceiling(Log(2,n*32));  t:=Ceiling(32*n/io);   k:=Ceiling(Log(2,32*n));
end if;


tcr:=Cputime();
// ______________________________query(m,x,Y,s)________________________________
prm:= -1;       id:=2^(k-io);
while not IsPrime(prm) do
     id:=id+1;
     prm:=id*S[query_index]+1;
end while;
G:=GF(prm);
//_________________________________cyclic group G ____________________________  
Gp:=PrimitiveElement(G);          indg:=(prm-1) div S[query_index];
for pj in P do
    if  indg mod pj eq 0 then
        indg:=indg div pj;
    end if;
end for;     
g:=Gp^indg;       

q:=Order(g) div S[query_index];   h:=g^q;        // user keep these private   

// __________________________answer_______________________
timeuser1:=Cputime(tcr);  
g_e:=g^e;				// server: answer
timeanswer:=Cputime(tcr) - timeuser1;     	

// ______________________ reconstruction___________________
he:=g_e^q;      result:=PH(h,he,prm) mod S[query_index];

timeuser:=Cputime(tcr) - timeanswer;
return <result,timeanswer,timeuser>;

end function;
print "finish loading gentry";
//_________________________after loading FUNCTION gentry_______________________





mx:=20;    itrivial:=    ;


for npower in [13..mx] do
     print "__________________the following results are with n=2^",npower;   
     n:=2^npower;   
     PrintFile("utime_gentry1231.txt","when n=2^" cat IntegerToString(npower));
     PrintFile("stime_gentry1231.txt","when n=2^" cat IntegerToString(npower)); 
     PrintFile("ptime_gentry1231.txt","when n=2^" cat IntegerToString(npower)); 

x:=[ 2^w-1 : i in [1..n] ];           query_input:=10;    // \in [0..n-1]

//___________________________________HASH________________________________________
Lay_num:= mx;          		     layer:=Lay_num-1;
HBBG:=[ []: i in[1..Lay_num-1] ];      HBBG[Lay_num]:=[ 2^w-1 : i in [1..2^mx] ];

while layer gt 0 do
       len:= #HBBG[layer+1];
       str1:= IntegerToString( HBBG[layer+1,1] );
       HBBG[layer]:= [SH6(StringToInteger(str1 cat str1)) : i in [1..2^layer]];
       layer:= layer - 1;
end while;

str1:= IntegerToString(HBBG[1,1]);
RootHBBG:= SH6( StringToInteger(str1 cat str1) );    
delete layer, str1;
//________________________________________________________________________________    
print "+HASH consumes", Cputime(tpre);          delete tpre;





//________________________________TIMING_____________________________
pret:=Cputime();
Ee:=[];     Pp:=[];     Ss:=[];	begnd:=[];
for sd in [itrivial+1..Lay_num] do
begnd[sd-itrivial]:=[];
  if sd eq Lay_num then
	     io:=Ceiling(Log(2,#HB[sd]));        t:=Ceiling(#HB[sd]/io); 
  else
	     io:=Ceiling(Log(2,hah*#HB[sd]));    t:=Ceiling(hah*#HB[sd]/io);
  end if;
	P:=[];        S:=[];    	P[1] :=NextPrime(2*t);    
	for i in [2..t] do
	      P[i]:=NextPrime(P[i-1]);
	end for;
	for pi in P do
	      temp:=Ceiling( io/Log(2,pi) );  S:=Append( S,pi^temp );    
	end for;
	delete temp;
        DB:=[];
        if sd eq Lay_num then
	for i in [1..t] do	   
	     if i lt t then
	      	     temp:=HB[sd][io*(i-1)+1..io* i];    
	     else    
               temp:=HB[sd][io*(i-1)+1..#HB[sd]]; 
	     end if;
	     DB[i]:=Seqint(temp,2); 
	end for;
        else
	for i in [1..t] do
	     begnd[sd-itrivial,i]:=[];	
	     begDBi:=io*(i-1)+1;             endDBi:=io*i;
	     ib1:=Ceiling(begDBi/hah);   ib2:=begDBi mod hah;
		if ib2 eq 0 then
		    ib2:=hah;
		end if;
	     ie1:=Ceiling(endDBi/hah);    ie2:=endDBi mod hah;
		if ie2 eq 0 then
		    iee:=hah;
		end if;		
	     begnd[sd-itrivial,i]:=[ib1,ib2,ie1,ie2];

       	     temp:=Intseq(HB[sd,ib1],2,hah)[ib2..Min(io+ib2-1,hah)];
	     if ie1-ib1 gt 1 then
	            for j in [ib1+1..ie1-1 ] do
		  tp:=Intseq(HB[sd,j],2,hah);
	                  temp:=temp cat tp; 
	            end for;
	     end if;
	     if ie1-ib1 eq 1 then
	           if ie1 gt #HB[sd] then
		tp:=[0: jk in[1..ie2] ];    
                           else 
		tp:=Intseq(HB[sd,ie1],2,hah)[1..ie2 ];     
	           end if;
	           temp:=temp cat tp; 
	     end if;

	     DB[i]:=Seqint(temp,2);
	end for;
        end if;     		// end for sd eq Lay_num

Ee[sd-itrivial]:=CRT(DB,S);          Pp[sd-itrivial]:=P;          Ss[sd-itrivial]:=S;
end for;    //end for sd in [itrivial+1...Lay_num]

pretime1:=Cputime(pret);

//_________________________find the involving indices__________________________		
alpha:=[0: indx in [1..Lay_num+1]];            // alpha stores these involving indices, starts from 0
alpha[Lay_num+1]:=query_input;        alpha[Lay_num]:= query_input + 1;

if query_input mod 2 eq 1 then 
     alpha[Lay_num]:= query_input - 1;
end if;

for j := Lay_num-1 to 1 by -1 do
     alpha[j]:= Floor(alpha[j+1]/2);
end for;



//______________________________________________________________________________
markind:=[];
for sd in [itrivial+1..Lay_num-1] do
markind[sd-itrivial]:=[];
for u in [1..2^sd] do
    markind[sd-itrivial,u]:=[];      //标记HB[sd,u]所在的位置
    markind[sd-itrivial,u,1]:=[Ceiling( ((u-1)*hah+1)/(sd+Log(2,hah)) ),  ((u-1)*hah+1) mod (sd+Ceiling(Log(2,hah)) ) ];
        if markind[sd-itrivial,u,1,2] eq 0 then
	markind[sd-itrivial,u,1,2]:=sd+Ceiling(Log(2,hah));
        end if;
    markind[sd-itrivial,u,2]:=[Ceiling( u*hah/(sd+Log(2,hah)) ),  u*hah mod (sd+Ceiling(Log(2,hah)) ) ];
        if markind[sd-itrivial,u,2,2] eq 0 then
	markind[sd-itrivial,u,2,2]:=sd+Ceiling(Log(2,hah));
        end if;
end for;
end for;













//210101







//_______________________________execute the PIR_______________________________
print "begin execute the single server PIR";
iterations:=10;
for cyc in [1..iterations] do   	      //**********iteration**********
servertime:=[];        usertime:=[];         Res:=[];      
	
ct:=Cputime();  
for itriv in [1..itrivial] do		   // trivial retrieval     
    Res[itriv]:=HB[itriv,alpha[itriv]+1]; 
end for;

for i in [itrivial+1..Lay_num-1] do 
	servertime[i-itrivial]:=0.0;        usertime[i-itrivial]:=0.0;          temp:=[];	
  qx:=alpha[i]+1;	     cac:=Min(i-itrivial,#markind);

	ts:=[];       tu:=[];
	for query_index in[markind[cac,qx,1,1]..markind[cac,qx,2,1]] do
        if i ge Lay_num then
	          io:=Ceiling( Log(2,2^Lay_num) );    	X:=HB[Lay_num];
	          Rep:=gentry(query_index,#X,Ee[Lay_num-itrivial],Ss[Lay_num-itrivial],Pp[Lay_num-itrivial],1);
        else    
	          io:=Ceiling( Log(2,32*2^i) );                 X:=HB[i];
            Rep:=gentry(query_index,hah*#X,Ee[i-itrivial],Ss[i-itrivial],Pp[i-itrivial],0);
        end if;
        
        if query_index eq markind[cac,qx,1,1] then
	          temp:=temp cat Intseq(Rep[1],2,io)[markind[cac,qx,1,2]..io];
        elif query_index lt markind[cac,qx,2,1] then
	          temp:=temp cat Intseq(Rep[1],2,io);
        else
	          temp:=temp cat Intseq(Rep[1],2,io)[1..markind[cac,qx,2,2]];
        end if;
        
        countq:=1;
	      ts[countq]:=Rep[2];        tu[countq]:=Rep[3];
	      countq:=countq+1;
	end for;

servertime[i-itrivial]:=&+ts;      usertime[i-itrivial]:=&+tu;
Res[i]:=Seqint(temp,2);  
end for;

for i in [Lay_num,Lay_num+1] do
      qx:=alpha[i]+1;        query_index:=Ceiling(qx/Lay_num);
      Rep:=gentry(query_index,#X,Ee[Lay_num-itrivial],Ss[Lay_num-itrivial],Pp[Lay_num-itrivial],1);
      Res[i]:=Intseq(Rep[1],2,Lay_num)[qx]; 
end for;






//___________________________Verification_Res_____________________________ 
vft:=Cputime(ct);                     
ver:=IntegerToString( Res[Lay_num+1] );         // MonStgElt 
j:=Lay_num;
while j gt 0 do
    tempj:=IntegerToString( Res[j] );                   // MonStgElt
    if IsOdd(alpha[j]) then
       ver:=IntegerToString( Hash(ver cat tempj) );
    else
       ver:=IntegerToString( Hash(tempj cat ver) );
    end if;
    j:=j-1;
end while;

if  ver eq IntegerToString(Root) then
     print "result",Res[#Res],", pass the verification";
else 
     print "result",Res[#Res],", does NOT pass the verification";
end if;

wholetime:=Cputime(ct);    //****time of query+reconstruction+verification
PrintFile("vtime_gentry.txt",wholetime-vft); 
utime:= &+usertime;	      // ******* time of query and reconstruction
stime:= &+servertime;      	      // ******* time of answer

PrintFile("utime_gentry.txt",utime);
PrintFile("stime_gentry.txt",stime); 
PrintFile("ptime_gentry.txt",vft-utime-stime); 

end for;   // end for the  40  iterations
end for;   // end for npower iterations
